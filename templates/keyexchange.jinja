{% block content %} 



<script>
    let received_messages = [];
    let known_keys = {};
    let connected_user = null;
    let active_key = null; 
    let g = 2
    let p = 11 //PUT BETTER PRIME HERE! pliz.


    function custom_parseInt() {

        var hash = sessionStorage.getItem("key")
        console.log("hash is " + hash);
        
        //iterate through hex hash and convert to decimal
        var seed = 0;
        var j = hash.length - 1;
        for(let i = 0; i < hash.length; i++){
            let number = parseInt(hash.charAt(i), 16);
            seed += number * (16 ** j)
            console.log("parsed " + hash.charAt(i) + " to " + parseInt(hash.charAt(i), 16) % 16);
            j -= 1;
        }
        console.log("calculated seed = " + seed);

        return seed;

    }

    //calculate random number from seed
    function custom_random(seed) {
        let state = seed;

        this.next = function() {
            state = (state * 9301 + 49297) % 9991548902539077689835780616603752428580731493961293799648588268547596371700;
            return state;
        };
    }

    
    function custom_rand_key(){
        let seed = custom_parseInt();

        //set seed
        const randomGenerator = new custom_random(seed);
        let key = randomGenerator.next();
        console.log("key generated: " + key);

        return key;
    }

    //let secret = parseInt(sessionStorage.getItem("key"), 10); //May cause errors or be a security flaw. 

    //Found online, the regular math.pow can't handle numbers as large as we are using. So. Functions it be. 
    function modularPow(base, exponent, modulus) {
        if (modulus === 1) return 0;
        var result = 1;
        base = base % modulus;
        while (exponent > 0) {
            if (exponent % 2 === 1) {
                result = (result * base) % modulus;
            }
            exponent = exponent >> 1; // Divide exponent by 2.
            base = (base * base) % modulus;
        }
        return result;
    }


    function check_existing_key(user_name) {
        return (user_name in known_keys);
    }

    function receiver(message) { //Accepts all the key-exchange relevent messages. 
        let message_obj = JSON.parse(message);
        message_obj['message'] = JSON.parse(message_obj['message']);
        console.log("triggered reciever",message_obj);

        if (message_obj["sender"] == connected_user && message_obj["message"]["type"] == "ciphertext") {
            console.log("Recieved message from connected user. Appending message");
            //append_message_content(decryptMessage(message_obj["message"]['content']),message_obj["sender"]);
            append_message_content(message_obj["message"]['content'],message_obj["sender"]);
        } else if (message_obj["message"]["type"] == "key_exchange") {
            if (message_obj['message']['sequence_num'] == 0) {
                console.log("Responding to key exchange");
                respond_key_exchange(message_obj["sender"]); //If this is the first messages recieved to init a key exchange, it goes straight to the respond to exchange funcion
            } else {
                received_messages.push(message_obj);
                console.log("Storing message for pass over.");
            }           
        }
    }

    async function init_connection(reciever_user_name) {
        if (!(check_existing_key(reciever_user_name))) {
            await init_key_exchange(reciever_user_name);
        }
        if (check_existing_key(reciever_user_name)) {
            connected_user = reciever_user_name;
            active_key = known_keys[reciever_user_name];
        }
    }
</script>

<script>
    //let g = 2
    //let p = 11 //PUT BETTER PRIME HERE! pliz.



    function craft_key_exchange_communication(content, sequence_num) {
        return JSON.stringify({
            type: "key_exchange",
            content: content,
            sequence_num: sequence_num
        });
    }

    function craft_message_communication(message) {
        return JSON.stringify({
            type: "ciphertext",
            content: message,
            sequence_num: null
        });
    }

    function get_recieved_message(expected_sequence_num,sender) {
        let found_message;
        for (var x = 0; x < received_messages.length; x++) {
            if (received_messages[x]['sender'] == sender) {
                if (received_messages[x]['message']['sequence_num'] == expected_sequence_num) {
                    found_message = received_messages[x]['message'];
                    received_messages.splice(x, 1);
                    return found_message;
                }
            }
        }
        return null;
    }

    async function check_responce_timeout(sequence_num,recipient) {
        recieved_message = null; 
        for (let x = 0; x < 5; x++) {
            console.log("Checking");
            recieved_message = get_recieved_message(sequence_num,recipient);
            if (!(recieved_message == null)) {
                break;
            }
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        return recieved_message; 
    }

    async function init_key_exchange(recipient) {
        var public_value = modularPow(g,secret,p);
        let recieved_message = null; 
        
        let sequence_num = 0; 
        relay(craft_key_exchange_communication("",sequence_num),recipient);
        
        sequence_num += 1; 
        await check_responce_timeout(sequence_num,recipient);

        sequence_num += 1; 
        relay(craft_key_exchange_communication(public_value,sequence_num),recipient);
        
        sequence_num += 1; 
        recieved_message = await check_responce_timeout(sequence_num,recipient);

        if (!(recieved_message == null)){
            known_keys[recipient] = modularPow(recieved_message['content'],secret,p);
            console.log("shared key established:",known_keys[recipient]);
        }
    }

    async function respond_key_exchange(sender) {
        var public_value = modularPow(g,secret,p);
        let recieved_message = null; 

        let sequence_num = 1;
        relay(craft_key_exchange_communication("",sequence_num),sender);

        sequence_num += 1; 
        recieved_message = await check_responce_timeout(sequence_num,sender);

        sequence_num += 1; 
        relay(craft_key_exchange_communication(public_value,sequence_num),sender);

        known_keys[sender] = modularPow(recieved_message['content'],secret,p);
        console.log("shared key established:",known_keys[sender]);
    }
</script>

{% endblock %}